var searchIndex = {};
searchIndex["slog"] = {"doc":"","items":[[3,"RecordInfo","slog","",null,null],[3,"RecordBuilder","","",null,null],[4,"Level","","",null,null],[13,"Critical","","",0,null],[13,"Error","","",0,null],[13,"Warning","","",0,null],[13,"Info","","",0,null],[13,"Debug","","",0,null],[13,"Trace","","",0,null],[0,"drain","","",null,null],[3,"Streamer","slog::drain","",null,null],[3,"FilterLevel","","Record log level filter",null,null],[3,"Duplicate","","Duplicate records into two drains",null,null],[5,"stream","","Create Streamer drain",null,{"inputs":[{"name":"w"}],"output":{"name":"streamer"}}],[5,"filter_level","","Create FilterLevel drain",null,{"inputs":[{"name":"level"},{"name":"d"}],"output":{"name":"filterlevel"}}],[5,"duplicate","","Create Duplicate drain",null,{"inputs":[{"name":"d1"},{"name":"d2"}],"output":{"name":"duplicate"}}],[8,"Drain","","",null,null],[10,"new_record","","",1,{"inputs":[{"name":"drain"},{"name":"recordinfo"}],"output":{"name":"option"}}],[8,"RecordDrain","","",null,null],[10,"add","","",2,{"inputs":[{"name":"recorddrain"},{"name":"str"},{"name":"display"}],"output":null}],[10,"end","","",2,{"inputs":[{"name":"recorddrain"}],"output":null}],[11,"new","","",3,{"inputs":[{"name":"w"}],"output":{"name":"self"}}],[11,"new_record","","",3,{"inputs":[{"name":"streamer"},{"name":"recordinfo"}],"output":{"name":"option"}}],[11,"new","","Create FilterLevel wrapping given `subdrain` and passing to it records\nonly of at least `level`.",4,{"inputs":[{"name":"level"},{"name":"d"}],"output":{"name":"self"}}],[11,"new_record","","",4,{"inputs":[{"name":"filterlevel"},{"name":"recordinfo"}],"output":{"name":"option"}}],[11,"new","","Create FilterLevel wrapping given `subdrain` and passing to it records\nonly of at least `level`.",5,{"inputs":[{"name":"d1"},{"name":"d2"}],"output":{"name":"self"}}],[11,"new_record","","",5,{"inputs":[{"name":"duplicate"},{"name":"recordinfo"}],"output":{"name":"option"}}],[0,"logger","slog","",null,null],[3,"Logger","slog::logger","",null,null],[3,"LoggerBuilder","","Logger builder",null,null],[11,"clone","","",6,{"inputs":[{"name":"logger"}],"output":{"name":"logger"}}],[11,"root","","Build a root logger",6,{"inputs":[],"output":{"name":"loggerbuilder"}}],[11,"new","","Build a child logger",6,{"inputs":[{"name":"logger"}],"output":{"name":"loggerbuilder"}}],[11,"new_root","","Build a root logger copying values",6,{"inputs":[{"name":"logger"}],"output":{"name":"loggerbuilder"}}],[11,"set_drain","","Set the drain for logger and it&#39;s hierarchy",6,{"inputs":[{"name":"logger"},{"name":"d"}],"output":null}],[11,"swap_drain","","Swap the existing drain with a new one",6,{"inputs":[{"name":"logger"},{"name":"arc"}],"output":{"name":"arc"}}],[11,"critical","","Log a critical level log record",6,{"inputs":[{"name":"logger"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"error","","Log an error level log record",6,{"inputs":[{"name":"logger"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"warning","","Log a warning level log record",6,{"inputs":[{"name":"logger"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"info","","Log an info level log record",6,{"inputs":[{"name":"logger"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"debug","","Log a debug level log record",6,{"inputs":[{"name":"logger"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"trace","","Log a trace level log record",6,{"inputs":[{"name":"logger"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"log","","Log a record with a given logging level",6,{"inputs":[{"name":"logger"},{"name":"level"},{"name":"str"}],"output":{"name":"recordbuilder"}}],[11,"add","","Add key-value pair",7,{"inputs":[{"name":"loggerbuilder"},{"name":"str"},{"name":"t"}],"output":{"name":"self"}}],[11,"end","","Finish building the logger",7,{"inputs":[{"name":"loggerbuilder"}],"output":{"name":"logger"}}],[11,"fmt","slog","",0,{"inputs":[{"name":"level"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"level"}],"output":{"name":"level"}}],[11,"as_str","","",0,{"inputs":[{"name":"level"}],"output":{"name":"str"}}],[11,"as_int","","",0,{"inputs":[{"name":"level"}],"output":{"name":"i32"}}],[11,"fmt","","",0,{"inputs":[{"name":"level"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"add","","",8,{"inputs":[{"name":"recordbuilder"},{"name":"str"},{"name":"t"}],"output":{"name":"self"}}],[11,"drop","","",8,{"inputs":[{"name":"recordbuilder"}],"output":null}]],"paths":[[4,"Level"],[8,"Drain"],[8,"RecordDrain"],[3,"Streamer"],[3,"FilterLevel"],[3,"Duplicate"],[3,"Logger"],[3,"LoggerBuilder"],[3,"RecordBuilder"]]};
searchIndex["crossbeam"] = {"doc":"Support for concurrent and parallel programming.","items":[[3,"Scope","crossbeam","",null,null],[3,"ScopedJoinHandle","","A handle to a scoped thread",null,null],[5,"scope","","Create a new `scope`, for deferred destructors.",null,{"inputs":[{"name":"f"}],"output":{"name":"r"}}],[5,"spawn_unsafe","","Like `std::thread::spawn`, but without the closure bounds.",null,{"inputs":[{"name":"f"}],"output":{"name":"joinhandle"}}],[0,"mem","","Memory management for concurrent data structures",null,null],[3,"CachePadded","crossbeam::mem","Pad `T` to the length of a cacheline.",null,null],[0,"epoch","","Epoch-based memory management",null,null],[3,"Atomic","crossbeam::mem::epoch","Like `std::sync::atomic::AtomicPtr`.",null,null],[3,"Guard","","An RAII-style guard for pinning the current epoch.",null,null],[3,"Owned","","Like `Box&lt;T&gt;`: an owned, heap-allocated data value of type `T`.",null,null],[3,"Shared","","Like `&amp;&#39;a T`: a shared reference valid for lifetime `&#39;a`.",null,null],[5,"pin","","Pin the current epoch.",null,{"inputs":[],"output":{"name":"guard"}}],[11,"null","","",0,{"inputs":[],"output":{"name":"atomic"}}],[11,"new","","Create a new atomic pointer",0,{"inputs":[{"name":"t"}],"output":{"name":"atomic"}}],[11,"load","","Do an atomic load with the given memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"option"}}],[11,"store","","Do an atomic store with the given memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"}],"output":null}],[11,"store_and_ref","","Do an atomic store with the given memory ordering, immediately yielding\na shared reference to the pointer that was stored.",0,{"inputs":[{"name":"atomic"},{"name":"owned"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"shared"}}],[11,"store_shared","","Do an atomic store of a `Shared` pointer with the given memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"}],"output":null}],[11,"cas","","Do a compare-and-set from a `Shared` to an `Owned` pointer with the\ngiven memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"option"},{"name":"ordering"}],"output":{"name":"result"}}],[11,"cas_and_ref","","Do a compare-and-set from a `Shared` to an `Owned` pointer with the\ngiven memory ordering, immediatley acquiring a new `Shared` reference to\nthe previously-owned pointer if successful.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"owned"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"result"}}],[11,"cas_shared","","Do a compare-and-set from a `Shared` to another `Shared` pointer with\nthe given memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"option"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"swap","","Do an atomic swap with an `Owned` pointer with the given memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"option"}}],[11,"swap_shared","","Do an atomic swap with a `Shared` pointer with the given memory ordering.",0,{"inputs":[{"name":"atomic"},{"name":"option"},{"name":"ordering"},{"name":"guard"}],"output":{"name":"option"}}],[11,"unlinked","","Assert that the value is no longer reachable from a lock-free data\nstructure and should be collected when sufficient epochs have passed.",1,{"inputs":[{"name":"guard"},{"name":"shared"}],"output":null}],[11,"migrate_garbage","","Move the thread-local garbage into the global set of garbage.",1,{"inputs":[{"name":"guard"}],"output":null}],[11,"drop","","",1,{"inputs":[{"name":"guard"}],"output":null}],[11,"new","","Move `t` to a new heap allocation.",2,{"inputs":[{"name":"t"}],"output":{"name":"owned"}}],[11,"into_inner","","Move data out of the owned box, deallocating the box.",2,{"inputs":[{"name":"owned"}],"output":{"name":"t"}}],[11,"deref","","",2,{"inputs":[{"name":"owned"}],"output":{"name":"t"}}],[11,"deref_mut","","",2,{"inputs":[{"name":"owned"}],"output":{"name":"t"}}],[11,"eq","","",3,{"inputs":[{"name":"shared"},{"name":"shared"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"shared"},{"name":"shared"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"shared"}],"output":{"name":"shared"}}],[11,"deref","","",3,{"inputs":[{"name":"shared"}],"output":{"name":"t"}}],[11,"as_raw","","",3,null],[11,"zeroed","crossbeam::mem","A const fn equivalent to mem::zeroed().",4,{"inputs":[],"output":{"name":"cachepadded"}}],[11,"new","","Wrap `t` with cacheline padding.",4,{"inputs":[{"name":"t"}],"output":{"name":"cachepadded"}}],[11,"deref","","",4,{"inputs":[{"name":"cachepadded"}],"output":{"name":"t"}}],[11,"deref_mut","","",4,{"inputs":[{"name":"cachepadded"}],"output":{"name":"t"}}],[8,"ZerosValid","","Types for which mem::zeroed() is safe.",null,null],[0,"sync","crossbeam","Synchronization primitives.",null,null],[3,"MsQueue","crossbeam::sync","A Michael-Scott lock-free queue, with support for blocking `pop`s.",null,null],[3,"AtomicOption","","",null,null],[3,"TreiberStack","","Treiber&#39;s lock-free stack.",null,null],[3,"SegQueue","","A Michael-Scott queue that allocates &quot;segments&quot; (arrays of nodes)\nfor efficiency.",null,null],[3,"ArcCell","","A type providing atomic storage and retrieval of an `Arc&lt;T&gt;`.",null,null],[11,"new","","",5,{"inputs":[],"output":{"name":"atomicoption"}}],[11,"swap_box","","",5,{"inputs":[{"name":"atomicoption"},{"name":"box"},{"name":"ordering"}],"output":{"name":"option"}}],[11,"swap","","",5,{"inputs":[{"name":"atomicoption"},{"name":"t"},{"name":"ordering"}],"output":{"name":"option"}}],[11,"take","","",5,{"inputs":[{"name":"atomicoption"},{"name":"ordering"}],"output":{"name":"option"}}],[11,"new","","Create a new, empty queue.",6,{"inputs":[],"output":{"name":"msqueue"}}],[11,"push","","Add `t` to the back of the queue, possibly waking up threads\nblocked on `pop`.",6,{"inputs":[{"name":"msqueue"},{"name":"t"}],"output":null}],[11,"is_empty","","Check if this queue is empty.",6,{"inputs":[{"name":"msqueue"}],"output":{"name":"bool"}}],[11,"try_pop","","Attempt to dequeue from the front.",6,{"inputs":[{"name":"msqueue"}],"output":{"name":"option"}}],[11,"pop","","Dequeue an element from the front of the queue, blocking if the queue is\nempty.",6,{"inputs":[{"name":"msqueue"}],"output":{"name":"t"}}],[11,"new","","Create a new, empty stack.",7,{"inputs":[],"output":{"name":"treiberstack"}}],[11,"push","","Push `t` on top of the stack.",7,{"inputs":[{"name":"treiberstack"},{"name":"t"}],"output":null}],[11,"pop","","Attempt to pop the top element of the stack.",7,{"inputs":[{"name":"treiberstack"}],"output":{"name":"option"}}],[11,"is_empty","","Check if this queue is empty.",7,{"inputs":[{"name":"treiberstack"}],"output":{"name":"bool"}}],[11,"new","","Create a new, empty queue.",8,{"inputs":[],"output":{"name":"segqueue"}}],[11,"push","","Add `t` to the back of the queue.",8,{"inputs":[{"name":"segqueue"},{"name":"t"}],"output":null}],[11,"try_pop","","Attempt to dequeue from the front.",8,{"inputs":[{"name":"segqueue"}],"output":{"name":"option"}}],[0,"chase_lev","","A lock-free concurrent work-stealing deque",null,null],[3,"Worker","crossbeam::sync::chase_lev","Worker half of the work-stealing deque. This worker has exclusive access to\none side of the deque, and uses `push` and `try_pop` method to manipulate it.",null,null],[3,"Stealer","","The stealing half of the work-stealing deque. Stealers have access to the\nopposite end of the deque from the worker, and they only have access to the\n`steal` method.",null,null],[4,"Steal","","When stealing some data, this is an enumeration of the possible outcomes.",null,null],[13,"Empty","","The deque was empty at the time of stealing",9,null],[13,"Abort","","The stealer lost the race for stealing data, and a retry may return more\ndata.",9,null],[13,"Data","","The stealer has successfully stolen some data.",9,null],[5,"deque","","Creates a new empty deque",null,null],[11,"fmt","","",9,{"inputs":[{"name":"steal"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"steal"},{"name":"steal"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"steal"},{"name":"steal"}],"output":{"name":"bool"}}],[11,"push","","Pushes data onto the front of this work queue.",10,{"inputs":[{"name":"worker"},{"name":"t"}],"output":null}],[11,"try_pop","","Pops data off the front of the work queue, returning `None` on an empty\nqueue.",10,{"inputs":[{"name":"worker"}],"output":{"name":"option"}}],[11,"steal","","Steals work off the end of the queue (opposite of the worker&#39;s end)",11,{"inputs":[{"name":"stealer"}],"output":{"name":"steal"}}],[11,"clone","","",11,{"inputs":[{"name":"stealer"}],"output":{"name":"stealer"}}],[11,"drop","crossbeam::sync","",12,{"inputs":[{"name":"arccell"}],"output":null}],[11,"new","","Creates a new `ArcCell`.",12,{"inputs":[{"name":"arc"}],"output":{"name":"arccell"}}],[11,"set","","Stores a new value in the `ArcCell`, returning the previous\nvalue.",12,{"inputs":[{"name":"arccell"},{"name":"arc"}],"output":{"name":"arc"}}],[11,"get","","Returns a copy of the value stored by the `ArcCell`.",12,{"inputs":[{"name":"arccell"}],"output":{"name":"arc"}}],[11,"defer","crossbeam","Schedule code to be executed when exiting the scope.",13,{"inputs":[{"name":"scope"},{"name":"f"}],"output":null}],[11,"spawn","","Create a scoped thread.",13,{"inputs":[{"name":"scope"},{"name":"f"}],"output":{"name":"scopedjoinhandle"}}],[11,"join","","Join the scoped thread, returning the result it produced.",14,{"inputs":[{"name":"scopedjoinhandle"}],"output":{"name":"t"}}],[11,"thread","","Get the underlying thread handle.",14,{"inputs":[{"name":"scopedjoinhandle"}],"output":{"name":"thread"}}],[11,"drop","","",13,{"inputs":[{"name":"scope"}],"output":null}]],"paths":[[3,"Atomic"],[3,"Guard"],[3,"Owned"],[3,"Shared"],[3,"CachePadded"],[3,"AtomicOption"],[3,"MsQueue"],[3,"TreiberStack"],[3,"SegQueue"],[4,"Steal"],[3,"Worker"],[3,"Stealer"],[3,"ArcCell"],[3,"Scope"],[3,"ScopedJoinHandle"]]};
initSearch(searchIndex);
